# 翻转图像
## 思路
1. 翻转每个子元素
    - 下标迁移法。利用tmp交换a[i][j] = a[i][len-j-1]
    - 指针法。利用left和right指针进行交换和遍历
    - 栈
    - 利用新的数组，反方向添加原数组元素
2. 反转每一行
    - 栈
    - 遍历取反
    - a[i][j] = 1 - a[i][j]
    - a[i][j] = a[i][j]^1
3. 规律法
    - 【110】变化为【100】，【101】变化为【010】，得出规律：如果两边不等则不需要变化，只需要变化中间。如果两边相等则需要取反，且变化中间。要判断数量的奇偶，如果是奇数则应该将中间的数抽出来进行变化。
4. 比较偏的方法
    - 将数组转化为字符串，所有的字符串根据规律取反
## 特殊情况
- 数组为空，直接退出
- 当元素不是数字时，直接跳过
- 当元素不是0，1时，正数取1，负数取0
## 代码
```c++
class Solution {
public:
    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {
        int n = A.size(), m = A[0].size();
        for(int i = 0; i < n; i++){
            for(int j = 0; j < (m+1)/2; j++) {
                if(A[i][j] == A[i][m-1-j]){
                    A[i][j] = A[i][m-1-j] = A[i][j]^1;
                }
            }
        }
        return A;
    }
};
```
## 注意点
- 如果要遍历包括所有的前半部分元素则要遍历到中点，则j < (a[0].size()+1)/2